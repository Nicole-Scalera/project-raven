<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/UI/UIManagerSaving.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/UI/UIManagerSaving.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;using UnityEngine.UI; // required for Button&#10;using System.Collections.Generic;&#10;using BasicMovement2_cf;&#10;using SceneSwitching_cf;&#10;using Sirenix.OdinInspector;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.SceneManagement;&#10;&#10;public class UIManagerSaving : MonoBehaviour, PlayerControls.IGameControlsActions&#10;{&#10;    // ===== Variables/Components =====&#10;    //private UIController canvasController; // Specific Canvas controller&#10;    [SerializeField] private UIController defaultCanvasController; // Default Canvas controller&#10;    [SerializeField] private Button[] buttons;&#10;    private GameObject otherObject; // Other object the player interacts with (Button)&#10;    private PlayerInputGameState playerInputGameState; // PlayerInput and GameState tuple&#10;    private GameStateManager.GameState currentState; // Current Game State&#10;    // Player References&#10;    private PlayerControls playerControls; // PlayerControls.cs&#10;    // ================================&#10;    &#10;    // ===== UIController Dictionary =====&#10;    // Create a new instance of a dictionary for a GameObject (button) and a UIController&#10;    private Dictionary&lt;GameObject, UIController&gt; UICanvasControllerDictionary = new();&#10;    private Dictionary&lt;PlayerInputGameState, UIController&gt; PlayerInputCanvasControllerDictionary = new();&#10;    [SerializeField, Required] private DictionaryComponent dictionaryComponent; // Reference to DictionaryComponent.cs&#10;    // ===================================&#10;    &#10;    // ===== Initialization =====&#10;    private void Awake()&#10;    {&#10;        // Get the dictionary component from this GameObject or its children&#10;        dictionaryComponent = GetComponent&lt;DictionaryComponent&gt;();&#10;        if (dictionaryComponent == null)&#10;        {&#10;            dictionaryComponent = GetComponentInChildren&lt;DictionaryComponent&gt;();&#10;        }&#10;&#10;        // Ensure the dictionaries are populated early (input can fire as soon as Awake)&#10;        GetDictionary();&#10;&#10;        // Initialize PlayerControls&#10;        playerControls = new PlayerControls();&#10;        playerControls.GameControls.SetCallbacks(this); // Set this class as listener&#10;        playerControls.GameControls.Enable();&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        CheckForClicks(); // Check for button clicks in the scene&#10;        &#10;        // Set the default canvas on scene start&#10;        _ToggleCanvasUI(defaultCanvasController);&#10;    }&#10;&#10;    // Get the UI canvas dictionary from DictionaryComponent.cs&#10;    private void GetDictionary()&#10;    {&#10;        if (dictionaryComponent != null)&#10;        {&#10;            // Grab the dictionaries from the object&#10;            UICanvasControllerDictionary = dictionaryComponent.UICanvasControllerDictionary;&#10;            PlayerInputCanvasControllerDictionary = dictionaryComponent.PlayerInputCanvasControllerDictionary;&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; No DictionaryComponent found on this object or its children.&quot;);&#10;        }&#10;    }&#10;&#10;    private void OnEnable()&#10;    {&#10;        GameStateManager.gameStateChanged += UpdateGameState;&#10;    }&#10;    &#10;    private void OnDisable()&#10;    {&#10;        GameStateManager.gameStateChanged -= UpdateGameState;&#10;    }&#10;&#10;    // Update the private reference of the current game state&#10;    private void UpdateGameState(GameStateManager.GameState state)&#10;    {&#10;        currentState = state;&#10;    }&#10;    // ==========================&#10;    &#10;    // =================== UI Input ===================&#10;    // Check for button clicks in the scene&#10;    private void CheckForClicks()&#10;    {&#10;        // Add listeners to each button in the buttons array&#10;        foreach (var button in buttons)&#10;        {&#10;            if (button == null || button.gameObject == null) continue;&#10;            // Add a listener that will pass the button.gameObject to our handler&#10;            button.onClick.AddListener(() =&gt; TaskOnClick(button.gameObject));&#10;        }&#10;    }&#10;&#10;    // Handle button click events&#10;    private void TaskOnClick(GameObject other)&#10;    {&#10;        Debug.Log(&quot;UIManagerSaving &gt; TaskOnClick Triggered by &quot; + other.gameObject.name);&#10;        &#10;        // Set the otherObject to the UI/collided object&#10;        otherObject = other.gameObject;&#10;        &#10;        // Call CheckForKey to see if it is in the dictionary&#10;        CheckForKeyUI(otherObject);&#10;    }&#10;    // ================================================&#10;    &#10;    // =================== UI Input ===================&#10;    // Handle button click events&#10;    public void OnTogglePause(InputAction.CallbackContext context)&#10;    {&#10;        // Only process when the action has been performed (avoids started/canceled duplicates)&#10;        if (!context.performed)&#10;        {&#10;            return;&#10;        }&#10;&#10;        // Safely read action and action map names from the context to avoid NullReferenceException&#10;        var action = context.action;&#10;        var actionName = action?.name;&#10;        var actionMapName = action?.actionMap?.name;&#10;&#10;        Debug.Log(&quot;UIManagerSaving &gt; TaskOnPlayerInput Triggered by action: &quot; + actionName + &quot; on map: &quot; + actionMapName);&#10;&#10;        if (string.IsNullOrEmpty(actionMapName))&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; OnTogglePause: actionMap name is null or empty. Aborting.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Compute the target (toggled) game state: this is the state we want to switch to&#10;        var current = GameStateManager.CurrentGameState;&#10;        var targetState = current == GameStateManager.GameState.Playing ? GameStateManager.GameState.Paused : GameStateManager.GameState.Playing;&#10;&#10;        // Create the key using the action map and the target state (so we look up the UI for the state we're switching into)&#10;        playerInputGameState = new PlayerInputGameState(actionMapName, targetState);&#10;&#10;        // Call CheckForKey to see if it is in the dictionary (using the target state)&#10;        CheckForKeyPlayerInput(playerInputGameState);&#10;    }&#10;    // ================================================&#10;    &#10;    // ================== Dictionary Logic ==================&#10;    // Call this in TaskOnClick&#10;    private void CheckForKeyUI(GameObject other)&#10;    {&#10;        if (other == null)&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; CheckForKeyUI called with null object&quot;);&#10;            return;&#10;        }&#10;&#10;        // Try to get the associated UIController from the dictionary safely&#10;        if (UICanvasControllerDictionary != null &amp;&amp; UICanvasControllerDictionary.TryGetValue(other, out UIController foundController))&#10;        {&#10;            Debug.Log($&quot;UIManagerSaving &gt; {other.name} Key found in dictionary! Toggling its UIController.&quot;);&#10;&#10;            // Toggle the associated UI canvas (use the found controller)&#10;            _ToggleCanvasUI(foundController);&#10;&#10;            // Keep a reference to the last-interacted object and its controller&#10;            otherObject = other;&#10;            return;&#10;        }&#10;&#10;        // If we get here, we didn't find a match&#10;        Debug.Log($&quot;UIManagerSaving &gt; {other.name} Key NOT found in dictionary after fallback checks!&quot;);&#10;        otherObject = null;&#10;    }&#10;    &#10;    // Call this in TaskOnPlayerInput&#10;    private void CheckForKeyPlayerInput(PlayerInputGameState other)&#10;    {&#10;        if (other.actionMap == null)&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; CheckForKeyPlayerInput called with null actionMap name&quot;);&#10;            return;&#10;        }&#10;&#10;        // Try to get the associated UIController from the dictionary safely&#10;        if (PlayerInputCanvasControllerDictionary != null &amp;&amp; PlayerInputCanvasControllerDictionary.TryGetValue(other, out UIController foundController))&#10;        {&#10;            Debug.Log($&quot;UIManagerSaving &gt; Key found in dictionary for {other.actionMap} and {other.gameState}! Toggling its UIController.&quot;);&#10;&#10;            // Set the GameState to the requested state contained in the key (we already computed the target)&#10;            GameStateManager.SetGameState(other.gameState);&#10;&#10;            // Toggle the associated UI canvas (use the found controller) and pass actionMap + the (now current) game state&#10;            _ToggleCanvasPlayerInput(foundController, other.actionMap, other.gameState);&#10;&#10;            // Keep a reference to the last-interacted object and its controller&#10;            playerInputGameState = other;&#10;            return;&#10;        }&#10;&#10;        // If we get here, we didn't find a match&#10;        Debug.Log($&quot;UIManagerSaving &gt; Key NOT found in dictionary for {other.actionMap} and {other.gameState}!&quot;);&#10;        otherObject = null;&#10;    }&#10;    // ======================================================&#10;&#10;    // ========== Toggling Canvases ==========&#10;    // Internal function to toggle the UI canvases: show 'canvas' and hide all others&#10;    void _ToggleCanvasUI(UIController canvas)&#10;    {&#10;        if (canvas == null)&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; _ToggleUICanvas called with null canvas. Hiding all dictionary controllers.&quot;);&#10;&#10;            // If canvas is null, just hide all dictionary controllers&#10;            foreach (var kvp in UICanvasControllerDictionary)&#10;            {&#10;                var c = kvp.Value;&#10;                if (c == null) continue;&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Hiding controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), false);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error hiding controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;            &#10;            return;&#10;        }&#10;&#10;        Debug.Log($&quot;UIManagerSaving &gt; Toggling UI Canvas: '{canvas.gameObject?.name ?? canvas.name}' (show) and hiding other dictionary controllers&quot;);&#10;&#10;        bool shownTargetFromDictionary = false;&#10;&#10;        // First, hide all dictionary controllers and mark whether the target was found in the dictionary&#10;        foreach (var kvp in UICanvasControllerDictionary)&#10;        {&#10;            var c = kvp.Value;&#10;            if (c == null) continue;&#10;&#10;            if (ReferenceEquals(c, canvas))&#10;            {&#10;                shownTargetFromDictionary = true;&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Showing controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), true);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error showing controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;            else&#10;            {&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Hiding controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), false);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error hiding controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;        }&#10;&#10;        // If the requested canvas isn't part of the dictionary, explicitly show it (so defaults work)&#10;        if (!shownTargetFromDictionary)&#10;        {&#10;            try&#10;            {&#10;                Debug.Log($&quot;You requested {canvas} controller.&quot;);&#10;                Debug.Log($&quot;UIManagerSaving &gt; Requested controller not part of dictionary. Explicitly showing '{canvas.gameObject?.name ?? canvas.name}' using index {canvas.ArraySize()}&quot;);&#10;                canvas.TogglePanel(canvas.ArraySize(), true);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                Debug.LogError($&quot;UIManagerSaving &gt; Error showing requested controller '{canvas.gameObject?.name ?? canvas.name}': {ex}&quot;);&#10;            }&#10;        }&#10;    }&#10;    &#10;    &#10;    // Internal function to toggle UI canvas with PlayerInputGameState&#10;    void _ToggleCanvasPlayerInput(UIController canvas, string actionMap, GameStateManager.GameState gameState)&#10;    {&#10;        if (canvas == null)&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; _ToggleUICanvas called with null canvas. Hiding all player-input dictionary controllers.&quot;);&#10;&#10;            // If canvas is null, just hide all dictionary controllers (player input dictionary)&#10;            foreach (var kvp in PlayerInputCanvasControllerDictionary)&#10;            {&#10;                var c = kvp.Value;&#10;                if (c == null) continue;&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Hiding controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), false);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error hiding controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;            &#10;            return;&#10;        }&#10;&#10;        Debug.Log($&quot;UIManagerSaving &gt; Toggling UI Canvas (PlayerInput): '{canvas.gameObject?.name ?? canvas.name}' (show) and hiding other player-input dictionary controllers&quot;);&#10;&#10;        bool shownTargetFromDictionary = false;&#10;&#10;        // Iterate the PlayerInput dictionary and compare the actionMap string + gameState to decide show/hide&#10;        foreach (var kvp in PlayerInputCanvasControllerDictionary)&#10;        {&#10;            var key = kvp.Key;&#10;            var c = kvp.Value;&#10;            if (c == null || key == null) continue;&#10;&#10;            bool keyMatches = string.Equals(key.actionMap, actionMap, StringComparison.Ordinal);&#10;            bool stateMatches = key.gameState == gameState;&#10;&#10;            if (keyMatches &amp;&amp; stateMatches &amp;&amp; ReferenceEquals(c, canvas))&#10;            {&#10;                shownTargetFromDictionary = true;&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Showing controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), true);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error showing controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;            else&#10;            {&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Hiding controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), false);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error hiding controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;        }&#10;&#10;        // If the requested canvas isn't part of the dictionary, explicitly show it (so defaults work)&#10;        if (!shownTargetFromDictionary)&#10;        {&#10;            try&#10;            {&#10;                Debug.Log($&quot;UIManagerSaving &gt; Requested controller not part of player-input dictionary. Explicitly showing '{canvas.gameObject?.name ?? canvas.name}' using index {canvas.ArraySize()}&quot;);&#10;                canvas.TogglePanel(canvas.ArraySize(), true);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                Debug.LogError($&quot;UIManagerSaving &gt; Error showing requested controller '{canvas.gameObject?.name ?? canvas.name}': {ex}&quot;);&#10;            }&#10;        }&#10;    }&#10;    // =======================================&#10;}" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;using UnityEngine.UI; // required for Button&#10;using System.Collections.Generic;&#10;using BasicMovement2_cf;&#10;using SceneSwitching_cf;&#10;using Sirenix.OdinInspector;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.SceneManagement;&#10;&#10;public class UIManagerSaving : MonoBehaviour, PlayerControls.IGameControlsActions&#10;{&#10;    // ===== Variables/Components =====&#10;    //private UIController canvasController; // Specific Canvas controller&#10;    [SerializeField] private UIController defaultCanvasController; // Default Canvas controller&#10;    [SerializeField] private Button[] buttons;&#10;    private GameObject otherObject; // Other object the player interacts with (Button)&#10;    private PlayerInputGameState playerInputGameState; // PlayerInput and GameState tuple&#10;    private GameStateManager.GameState currentState; // Current Game State&#10;    // Player References&#10;    private PlayerControls playerControls; // PlayerControls.cs&#10;    // ================================&#10;    &#10;    // ===== UIController Dictionary =====&#10;    // Create a new instance of a dictionary for a GameObject (button) and a UIController&#10;    private Dictionary&lt;GameObject, UIController&gt; UICanvasControllerDictionary = new();&#10;    private Dictionary&lt;PlayerInputGameState, UIController&gt; PlayerInputCanvasControllerDictionary = new();&#10;    [SerializeField, Required] private DictionaryComponent dictionaryComponent; // Reference to DictionaryComponent.cs&#10;    // ===================================&#10;    &#10;    // ===== Initialization =====&#10;    private void Awake()&#10;    {&#10;        // Get the dictionary component from this GameObject or its children&#10;        dictionaryComponent = GetComponent&lt;DictionaryComponent&gt;();&#10;        if (dictionaryComponent == null)&#10;        {&#10;            dictionaryComponent = GetComponentInChildren&lt;DictionaryComponent&gt;();&#10;        }&#10;&#10;        // Ensure the dictionaries are populated early (input can fire as soon as Awake)&#10;        GetDictionary();&#10;&#10;        // Initialize PlayerControls&#10;        playerControls = new PlayerControls();&#10;        playerControls.GameControls.SetCallbacks(this); // Set this class as listener&#10;        playerControls.GameControls.Enable();&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        CheckForClicks(); // Check for button clicks in the scene&#10;        &#10;        // Set the default canvas on scene start&#10;        _ToggleCanvasUI(defaultCanvasController);&#10;    }&#10;&#10;    // Get the UI canvas dictionary from DictionaryComponent.cs&#10;    private void GetDictionary()&#10;    {&#10;        if (dictionaryComponent != null)&#10;        {&#10;            // Grab the dictionaries from the object&#10;            UICanvasControllerDictionary = dictionaryComponent.UICanvasControllerDictionary;&#10;            PlayerInputCanvasControllerDictionary = dictionaryComponent.PlayerInputCanvasControllerDictionary;&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; No DictionaryComponent found on this object or its children.&quot;);&#10;        }&#10;    }&#10;&#10;    private void OnEnable()&#10;    {&#10;        GameStateManager.gameStateChanged += UpdateGameState;&#10;    }&#10;    &#10;    private void OnDisable()&#10;    {&#10;        GameStateManager.gameStateChanged -= UpdateGameState;&#10;    }&#10;&#10;    // Update the private reference of the current game state&#10;    private void UpdateGameState(GameStateManager.GameState state)&#10;    {&#10;        currentState = state;&#10;    }&#10;    // ==========================&#10;    &#10;    // =================== UI Input ===================&#10;    // Check for button clicks in the scene&#10;    private void CheckForClicks()&#10;    {&#10;        // Add listeners to each button in the buttons array&#10;        foreach (var button in buttons)&#10;        {&#10;            if (button == null || button.gameObject == null) continue;&#10;            // Add a listener that will pass the button.gameObject to our handler&#10;            button.onClick.AddListener(() =&gt; TaskOnClick(button.gameObject));&#10;        }&#10;    }&#10;&#10;    // Handle button click events&#10;    private void TaskOnClick(GameObject other)&#10;    {&#10;        Debug.Log(&quot;UIManagerSaving &gt; TaskOnClick Triggered by &quot; + other.gameObject.name);&#10;        &#10;        // Set the otherObject to the UI/collided object&#10;        otherObject = other.gameObject;&#10;        &#10;        // Call CheckForKey to see if it is in the dictionary&#10;        CheckForKeyUI(otherObject);&#10;    }&#10;    // ================================================&#10;    &#10;    // =================== UI Input ===================&#10;    // Handle button click events&#10;    public void OnTogglePause(InputAction.CallbackContext context)&#10;    {&#10;        // Only process when the action has been performed (avoids started/canceled duplicates)&#10;        if (!context.performed)&#10;        {&#10;            return;&#10;        }&#10;&#10;        // Safely read action and action map names from the context to avoid NullReferenceException&#10;        var action = context.action;&#10;        var actionName = action?.name;&#10;        var actionMapName = action?.actionMap?.name;&#10;&#10;        Debug.Log(&quot;UIManagerSaving &gt; TaskOnPlayerInput Triggered by action: &quot; + actionName + &quot; on map: &quot; + actionMapName);&#10;&#10;        if (string.IsNullOrEmpty(actionMapName))&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; OnTogglePause: actionMap name is null or empty. Aborting.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Compute the target (toggled) game state: this is the state we want to switch to&#10;        var current = GameStateManager.CurrentGameState;&#10;        var targetState = current == GameStateManager.GameState.Playing ? GameStateManager.GameState.Paused : GameStateManager.GameState.Playing;&#10;&#10;        // Create the key using the action map and the target state (so we look up the UI for the state we're switching into)&#10;        playerInputGameState = new PlayerInputGameState(actionMapName, targetState);&#10;&#10;        // Call CheckForKey to see if it is in the dictionary (using the target state)&#10;        CheckForKeyPlayerInput(playerInputGameState);&#10;    }&#10;    // ================================================&#10;    &#10;    // ================== Dictionary Logic ==================&#10;    // Call this in TaskOnClick&#10;    private void CheckForKeyUI(GameObject other)&#10;    {&#10;        if (other == null)&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; CheckForKeyUI called with null object&quot;);&#10;            return;&#10;        }&#10;&#10;        // Try to get the associated UIController from the dictionary safely&#10;        if (UICanvasControllerDictionary != null &amp;&amp; UICanvasControllerDictionary.TryGetValue(other, out UIController foundController))&#10;        {&#10;            Debug.Log($&quot;UIManagerSaving &gt; {other.name} Key found in dictionary! Toggling its UIController.&quot;);&#10;&#10;            // Toggle the associated UI canvas (use the found controller)&#10;            _ToggleCanvasUI(foundController);&#10;&#10;            // Keep a reference to the last-interacted object and its controller&#10;            otherObject = other;&#10;            return;&#10;        }&#10;&#10;        // If we get here, we didn't find a match&#10;        Debug.Log($&quot;UIManagerSaving &gt; {other.name} Key NOT found in dictionary after fallback checks!&quot;);&#10;        otherObject = null;&#10;    }&#10;    &#10;    // Call this in TaskOnPlayerInput&#10;    private void CheckForKeyPlayerInput(PlayerInputGameState other)&#10;    {&#10;        if (other.actionMap == null)&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; CheckForKeyPlayerInput called with null actionMap name&quot;);&#10;            return;&#10;        }&#10;&#10;        // Try to get the associated UIController from the dictionary safely&#10;        if (PlayerInputCanvasControllerDictionary != null &amp;&amp; PlayerInputCanvasControllerDictionary.TryGetValue(other, out UIController foundController))&#10;        {&#10;            Debug.Log($&quot;UIManagerSaving &gt; Key found in dictionary for {other.actionMap} and {other.gameState}! Toggling its UIController.&quot;);&#10;&#10;            // Set the GameState to the requested state contained in the key (we already computed the target)&#10;            GameStateManager.SetGameState(other.gameState);&#10;&#10;            // Toggle the associated UI canvas (use the found controller) and pass actionMap + the (now current) game state&#10;            _ToggleCanvasPlayerInput(foundController, other.actionMap, other.gameState);&#10;&#10;            // Keep a reference to the last-interacted object and its controller&#10;            playerInputGameState = other;&#10;            return;&#10;        }&#10;&#10;        // If we get here, we didn't find a match&#10;        Debug.Log($&quot;UIManagerSaving &gt; Key NOT found in dictionary for {other.actionMap} and {other.gameState}!&quot;);&#10;        otherObject = null;&#10;    }&#10;    // ======================================================&#10;&#10;    // ========== Toggling Canvases ==========&#10;    // Internal function to toggle the UI canvases: show 'canvas' and hide all others&#10;    void _ToggleCanvasUI(UIController canvas)&#10;    {&#10;        if (canvas == null)&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; _ToggleUICanvas called with null canvas. Hiding all dictionary controllers.&quot;);&#10;&#10;            // If canvas is null, just hide all dictionary controllers&#10;            foreach (var kvp in UICanvasControllerDictionary)&#10;            {&#10;                var c = kvp.Value;&#10;                if (c == null) continue;&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Hiding controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), false);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error hiding controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;            &#10;            return;&#10;        }&#10;&#10;        Debug.Log($&quot;UIManagerSaving &gt; Toggling UI Canvas: '{canvas.gameObject?.name ?? canvas.name}' (show) and hiding other dictionary controllers&quot;);&#10;&#10;        bool shownTargetFromDictionary = false;&#10;&#10;        // First, hide all dictionary controllers and mark whether the target was found in the dictionary&#10;        foreach (var kvp in UICanvasControllerDictionary)&#10;        {&#10;            var c = kvp.Value;&#10;            if (c == null) continue;&#10;&#10;            if (ReferenceEquals(c, canvas))&#10;            {&#10;                shownTargetFromDictionary = true;&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Showing controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), true);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error showing controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;            else&#10;            {&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Hiding controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), false);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error hiding controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;        }&#10;&#10;        // If the requested canvas isn't part of the dictionary, explicitly show it (so defaults work)&#10;        if (!shownTargetFromDictionary)&#10;        {&#10;            try&#10;            {&#10;                Debug.Log($&quot;You requested {canvas} controller.&quot;);&#10;                Debug.Log($&quot;UIManagerSaving &gt; Requested controller not part of dictionary. Explicitly showing '{canvas.gameObject?.name ?? canvas.name}' using index {canvas.ArraySize()}&quot;);&#10;                canvas.TogglePanel(canvas.ArraySize(), true);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                Debug.LogError($&quot;UIManagerSaving &gt; Error showing requested controller '{canvas.gameObject?.name ?? canvas.name}': {ex}&quot;);&#10;            }&#10;        }&#10;    }&#10;    &#10;    &#10;    // Internal function to toggle UI canvas with PlayerInputGameState&#10;    void _ToggleCanvasPlayerInput(UIController canvas, string actionMap, GameStateManager.GameState gameState)&#10;    {&#10;        if (canvas == null)&#10;        {&#10;            Debug.LogWarning(&quot;UIManagerSaving &gt; _ToggleUICanvas called with null canvas. Hiding all player-input dictionary controllers.&quot;);&#10;&#10;            // If canvas is null, just hide all dictionary controllers (player input dictionary)&#10;            foreach (var kvp in PlayerInputCanvasControllerDictionary)&#10;            {&#10;                var c = kvp.Value;&#10;                if (c == null) continue;&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Hiding controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), false);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error hiding controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;            &#10;            return;&#10;        }&#10;&#10;        Debug.Log($&quot;UIManagerSaving &gt; Toggling UI Canvas (PlayerInput): '{canvas.gameObject?.name ?? canvas.name}' (show) and hiding other player-input dictionary controllers&quot;);&#10;&#10;        bool shownTargetFromDictionary = false;&#10;&#10;        // Iterate the PlayerInput dictionary and compare the actionMap string + gameState to decide show/hide&#10;        foreach (var kvp in PlayerInputCanvasControllerDictionary)&#10;        {&#10;            var key = kvp.Key;&#10;            var c = kvp.Value;&#10;            if (c == null || key == null) continue;&#10;&#10;            bool keyMatches = string.Equals(key.actionMap, actionMap, StringComparison.Ordinal);&#10;            bool stateMatches = key.gameState == gameState;&#10;&#10;            if (keyMatches &amp;&amp; stateMatches &amp;&amp; ReferenceEquals(c, canvas))&#10;            {&#10;                shownTargetFromDictionary = true;&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Showing controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), true);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error showing controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;            else&#10;            {&#10;                try&#10;                {&#10;                    Debug.Log($&quot;UIManagerSaving &gt; Hiding controller '{c.gameObject?.name ?? c.name}' using index {c.ArraySize()}&quot;);&#10;                    c.TogglePanel(c.ArraySize(), false);&#10;                }&#10;                catch (Exception ex) { Debug.LogError($&quot;UIManagerSaving &gt; Error hiding controller '{c.gameObject?.name ?? c.name}': {ex}&quot;); }&#10;            }&#10;        }&#10;&#10;        // If the requested canvas isn't part of the dictionary, explicitly show it (so defaults work)&#10;        if (!shownTargetFromDictionary)&#10;        {&#10;            try&#10;            {&#10;                Debug.Log($&quot;UIManagerSaving &gt; Requested controller not part of player-input dictionary. Explicitly showing '{canvas.gameObject?.name ?? canvas.name}' using index {canvas.ArraySize()}&quot;);&#10;                canvas.TogglePanel(canvas.ArraySize(), true);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                Debug.LogError($&quot;UIManagerSaving &gt; Error showing requested controller '{canvas.gameObject?.name ?? canvas.name}': {ex}&quot;);&#10;            }&#10;        }&#10;    }&#10;    // =======================================&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>